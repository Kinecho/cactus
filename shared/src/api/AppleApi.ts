import {isNull} from "@shared/util/ObjectUtil";
import {ISODate} from "@shared/mailchimp/models/MailchimpTypes";
import SubscriptionProduct from "@shared/models/SubscriptionProduct";

export interface AppleCompletePurchaseRequest {
    /**
     * Base 64 encoded receipt string
     */
    receiptData: string
}

export interface AppleFulfillmentResult {
    success: boolean,
    message?: string,
    subscriptionProduct?: SubscriptionProduct
}

export interface AppleCompletePurchaseResult {
    success: boolean,
    isValid?: boolean,
    fulfillmentResult?: AppleFulfillmentResult,
    message?: string
    error?: string,
    appleReceiptData?: AppleReceiptResponseRawBody,
}

export function isCompletePurchaseRequest(input: any): input is AppleCompletePurchaseRequest {
    return !isNull(input) && !!(input as AppleCompletePurchaseRequest).receiptData;
}

export function isAppleReceiptResponseRawBody(input: any): input is AppleReceiptResponseRawBody {
    return !isNull(input) && (input as AppleReceiptResponseRawBody).status !== undefined
}

type BooleanString = "true" | "false"

/**
 * See [Apple Docs](https://developer.apple.com/documentation/appstorereceipts/responsebody/latest_receipt_info)
 */
export interface AppleTransactionInfo {
    /**
     * The time Apple customer support canceled a transaction, in a date-time format similar to the ISO 8601. This field is only present for refunded transactions.
     */
    cancellation_date?: ISODate;
    cancellation_date_ms?: string;
    cancellation_date_pst?: string;

    /**
     * The reason for a refunded transaction. When a customer cancels a transaction, the App Store gives them a refund and provides a value for this key. A value of “1” indicates that the customer canceled their transaction due to an actual or perceived issue within your app. A value of “0” indicates that the transaction was canceled for another reason; for example, if the customer made the purchase accidentally.
     Possible values: 1, 0
     */
    cancellation_reason?: "0" | "1";
    expires_date?: ISODate;
    expires_date_ms?: string;
    expires_date_pst?: string;

    /**
     * An indicator of whether an auto-renewable subscription is in the introductory price period. See [is_in_intro_offer_period](https://developer.apple.com/documentation/appstorereceipts/is_in_intro_offer_period) for more information.
     */
    is_in_intro_offer_period?: BooleanString
    is_trial_period?: BooleanString
    is_upgraded?: BooleanString
    original_purchase_date?: ISODate
    original_purchase_date_ms?: string;
    original_purchase_date_pst?: string;
    original_transaction_id: string;
    product_id: string;
    promotional_offer_id?: string;
    purchase_date?: ISODate;
    purchase_date_ms?: string;
    purchase_date_pst?: string;
    quantity: string;
    subscription_group_identifier?: string;
    transaction_id?: string;
    web_order_line_item_id?: string;

    [key: string]: any
}

/**
 * The decoded version of the encoded receipt data sent with the request to the App Store.
 */
export interface AppleReceipt {
    adam_id?: number;
    /**
     * Generated by App Store Connect and used by the App Store to uniquely identify the app purchased. Apps are assigned this identifier only in production. Treat this value as a 64-bit long integer.
     */
    app_item_id?: number;
    application_version?: number;
    bundle_id?: string;
    download_id?: number;
    expiration_date?: string;
    expiration_date_ms?: string;
    expiration_date_pst?: string;
    in_app?: AppleTransactionInfo[];
    original_application_version?: string;
    original_purchase_date?: string;
    original_purchase_date_ms?: string;
    original_purchase_date_pst?: string;
    preorder_date?: string;
    preorder_date_ms?: string;
    preorder_date_pst?: string;
    receipt_creation_date?: string;
    receipt_creation_date_ms?: string;
    receipt_creation_date_pst?: string;
    receipt_type?: string;
    request_date?: string;
    request_date_ms?: string;
    request_date_pst?: string;
    version_external_identifier?: number;

    [key: string]: any
}

/**
 * The reason a subscription expired.
 */
export enum ExpirationIntent {
    /**
     * The customer voluntarily canceled their subscription.
     */
    customer_canceled = "1",

    /**
     * Billing error; for example, the customer's payment information was no longer valid.
     */
    billing_error = "2",

    /**
     * The customer did not agree to a recent price increase.
     */
    customer_denied_price_increase = "3",

    /**
     * The product was not available for purchase at the time of renewal.
     */
    product_not_available = "4",

    /**
     * Unknown Error
     */
        unknown = "5"
}

export function getExpirationIntentDescription(intent?: ExpirationIntent): string | undefined {
    if (!intent) {
        return undefined;
    }
    switch (intent) {
        case ExpirationIntent.customer_canceled:
            return "The customer voluntarily canceled their subscription.";
        case ExpirationIntent.billing_error:
            return "Billing error; for example, the customer's payment information was no longer valid.";
        case ExpirationIntent.customer_denied_price_increase:
            return "The customer did not agree to a recent price increase.";
        case ExpirationIntent.product_not_available:
            return "The product was not available for purchase at the time of renewal.";
        case ExpirationIntent.unknown:
            return "Unknown error"
    }
}

export interface PendingRenewalInfo {
    auto_renew_product_id?: string;

    /**
     * 1 = The subscription will renew at the end of the current subscription period.
     * 0 = The customer has turned off automatic renewal for the subscription.
     */
    auto_renew_status: "0" | "1";
    /**
     * The reason a subscription expired. This field is only present for a receipt that contains an expired auto-renewable subscription.
     */
    expiration_intent?: ExpirationIntent;
    grace_period_expires_date?: string;
    grace_period_expires_date_ms?: string;
    grace_period_expires_date_pst?: string;
    is_in_billing_retry_period?: "0" | "1";
    original_transaction_id?: string;
    price_consent_status?: "0" | "1";
    product_id?: string;
}

/**
 * see [Apple Docs](https://developer.apple.com/documentation/appstorereceipts/responsebody)
 */
export interface AppleReceiptResponseRawBody {
    environment: "Sandbox" | "Production";
    "is-retryable": boolean;
    /**
     * Base64 encoded string
     */
    latest_receipt: string; //base 64 encoded string
    /**
     * An array that contains all in-app purchase transactions.
     * This excludes transactions for consumable products that have been marked as finished by your app.
     * Only returned for receipts that contain auto-renewable subscriptions.
     */
    latest_receipt_info: AppleTransactionInfo[];

    /**
     * In the JSON file, an array where each element contains the pending renewal
     * information for each auto-renewable subscription identified by the product_id.
     * Only returned for app receipts that contain auto-renewable subscriptions.
     */
    pending_renewal_info: PendingRenewalInfo[];

    /**
     * A JSON representation of the receipt that was sent for verification.
     */
    receipt: AppleReceipt;

    /**
     * Either 0 if the receipt is valid, or a status code if there is an error.
     * The status code reflects the status of the app receipt as a whole.
     * See status for possible status codes and descriptions.
     */
    status: ReceiptStatusCode;
}

export enum ReceiptStatusCode {
    valid = 0,
    receipt_is_test_environment = 21007,
    internal_error = 21009,
    invalid_http_verb = 21000,
    deprecated_status_code = 21001,
    malformed_data = 21002,
    not_authorized = 21003,
    shared_secret_invalid = 21004,
    server_not_availalbe = 21005,
    subscription_expired = 21006,
    receipt_is_prod_environment = 21008,
    user_account_not_found_or_deleted = 21010,
}

export const AppleReceiptCode = {
    21000: "The request to the App Store was not made using the HTTP POST request method.",
    21001: "This status code is no longer sent by the App Store.",
    21002: "The data in the receipt-data property was malformed or missing.",
    21003: "The receipt could not be authenticated.",
    21004: "The shared secret you provided does not match the shared secret on file for your account.",
    21005: "The receipt server is not currently available.",
    21006: "This receipt is valid but the subscription has expired. When this status code is returned to your server, the receipt data is also decoded and returned as part of the response. Only returned for iOS 6-style transaction receipts for auto-renewable subscriptions.",
    21007: "This receipt is from the test environment, but it was sent to the production environment for verification.",
    21008: "This receipt is from the production environment, but it was sent to the test environment for verification.",
    21009: "Internal data access error. Try again later.",
    21010: "The user account cannot be found or has been deleted."
};

export function getOriginalTransactionId(receipt?: AppleReceiptResponseRawBody): string | undefined {
    if (!receipt) {
        return undefined;
    }
    const [nextRenewal] = receipt.pending_renewal_info ?? [];
    const [lastInfo] = receipt.latest_receipt_info ?? [];
    return nextRenewal.original_transaction_id ?? lastInfo?.original_transaction_id;
}

/**
 * Apple notification type for subscription event
 * See [Apple Docs](https://developer.apple.com/documentation/appstoreservernotifications/notification_type)
 */
export enum AppleNotificationType {
    /**
     * Indicates that either Apple customer support canceled the subscription or the user upgraded their subscription.
     * The cancellation_date key contains the date and time of the change.
     */
    CANCEL = "CANCEL",

    /**
     * Indicates the customer made a change in their subscription plan that takes effect at the next renewal.
     * The currently active plan is not affected.
     */
    DID_CHANGE_RENEWAL_PREF = "DID_CHANGE_RENEWAL_PREF",

    /**
     * Indicates a change in the subscription renewal status.
     * Check auto_renew_status_change_date_ms and auto_renew_status in the JSON response
     * to know the date and time of the last status update and the current renewal status.
     */
    DID_CHANGE_RENEWAL_STATUS = "DID_CHANGE_RENEWAL_STATUS",

    /**
     * Indicates a subscription that failed to renew due to a billing issue.
     * Check is_in_billing_retry_period to know the current retry status of the subscription,
     * and grace_period_expires_date to know the new service expiration date if the subscription is in a billing grace period.
     */
    DID_FAIL_TO_RENEW = "DID_FAIL_TO_RENEW",

    /**
     * Indicates successful automatic renewal of an expired subscription that failed to renew in the past.
     * Check expires_date to determine the next renewal date and time.
     */
    DID_RECOVER = "DID_RECOVER",

    /**
     * Occurs at the initial purchase of the subscription.
     * Store latest_receipt on your server as a token to verify the user’s subscription status at any time,
     * by validating it with the App Store.
     */
    INITIAL_BUY = "INITIAL_BUY",

    /**
     * Indicates the customer renewed a subscription interactively, either by using your app’s interface,
     * or on the App Store in the account's Subscriptions settings. Make service available immediately.
     */
    INTERACTIVE_RENEWAL = "INTERACTIVE_RENEWAL",

    /**
     * Indicates successful automatic renewal of an expired subscription that failed to renew in the past.
     * Check expires_date to determine the next renewal date and time.
     */
    RENEWAL = "RENEWAL",
}

/**
 * Data type sent from Apple on server-to-server notifications such as Subscription Status changes
 * See [Apple Docs](https://developer.apple.com/documentation/appstoreservernotifications/responsebody)
 */
export interface AppleServerNotificationBody {
    notification_type: AppleNotificationType
    password: string
    auto_renew_adam_id?: string
    auto_renew_product_id: string
    auto_renew_status: "true" | "false"
    auto_renew_status_change_date: ISODate
    auto_renew_status_change_date_ms: string,
    auto_renew_status_change_date_pst: string,
    environment: "Sandbox" | "PROD"
    expiration_intent?: ExpirationIntent

    /**
     * The latest Base64-encoded transaction receipt. This field appears in the notification instead of latest_receipt for expired transactions.
     */
    latest_expired_receipt?: string
    latest_expired_receipt_info?: AppleTransactionInfo[]

    latest_receipt: string

    /**
     * The JSON representation of the value in latest_receipt. Note that this field is an array in the receipt but a single object in server-to-server notifications.
     */
    latest_receipt_info: AppleTransactionInfo

    /**
     * An object that contains information about the most recent in-app purchase transactions for the app.
     */
    unified_receipt: AppleUnifiedReceipt;
}

export function isAppleServerNotification(input: any): input is AppleServerNotificationBody {
    if (isNull(input)) {
        return false
    }

    return !isNull((input as AppleServerNotificationBody).auto_renew_product_id) && !isNull((input as AppleServerNotificationBody).password)
}

export function getOriginalTransactionIdFromServerNotification(notification: AppleServerNotificationBody): string | undefined {
    if (!notification) {
        return undefined;
    }
    const [nextRenewal] = notification.unified_receipt?.pending_renewal_info ?? [];
    const lastInfo = notification.latest_receipt_info;
    return lastInfo?.original_transaction_id ?? nextRenewal?.original_transaction_id;
}


export function getExpirationIntentFromNotification(notification: AppleServerNotificationBody): ExpirationIntent | undefined {
    if (!notification) {
        return undefined;
    }
    const [nextRenewal] = notification.unified_receipt?.pending_renewal_info ?? [];
    return notification.expiration_intent ?? nextRenewal?.expiration_intent;
}

export interface AppleUnifiedReceipt {
    environment: "Sandbox" | "Production"
    /**
     * encoded receipt string
     */
    latest_receipt: string
    /**
     * An array that contains the latest 100 in-app purchase transactions of the decoded value in latest_receipt.
     * This array excludes transactions for consumable products that your app has marked as finished.
     * The contents of this array are identical to those in responseBody.Latest_receipt_info
     * in the verifyReceipt endpoint response for receipt validation.
     */
    latest_receipt_info: AppleTransactionInfo[]

    /**
     * An array where each element contains the pending renewal information for each auto-renewable subscription identified in product_id.
     * The contents of this array are identical
     * to those in responseBody.Pending_renewal_info in the verifyReciept endpoint response for receipt validation.
     */
    pending_renewal_info: PendingRenewalInfo[]
    status: 0
}